<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LEGO City Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #gameCanvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 16px;
            max-width: 300px;
        }
        #ui h2 {
            margin: 0 0 10px 0;
        }
        #ui p {
            margin: 5px 0;
        }
        .highlight {
            color: #00ff00;
            font-weight: bold;
        }
        
        /* Joystick styles */
        #joystick-container {
            position: absolute;
            bottom: 80px;
            left: 80px;
            width: 150px;
            height: 150px;
            display: none; /* Hidden by default, shown on touch devices */
        }
        #joystick-base {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.3);
            border: 3px solid rgba(255, 255, 255, 0.5);
            position: relative;
        }
        #joystick-stick {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(255, 100, 100, 0.8);
            border: 3px solid rgba(255, 255, 255, 0.7);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            touch-action: none;
        }
        
        /* Action button */
        #action-button {
            position: absolute;
            bottom: 100px;
            right: 80px;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background-color: rgba(100, 255, 100, 0.7);
            border: 3px solid rgba(255, 255, 255, 0.7);
            display: none; /* Hidden by default */
            font-size: 32px;
            color: white;
            text-align: center;
            line-height: 80px;
            font-weight: bold;
            user-select: none;
            touch-action: none;
        }
        #action-button:active {
            background-color: rgba(100, 255, 100, 1);
        }
        
        /* Jump button */
        #jump-button {
            position: absolute;
            bottom: 200px;
            right: 80px;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background-color: rgba(255, 200, 100, 0.7);
            border: 3px solid rgba(255, 255, 255, 0.7);
            display: none; /* Hidden by default */
            font-size: 28px;
            color: white;
            text-align: center;
            line-height: 80px;
            font-weight: bold;
            user-select: none;
            touch-action: none;
        }
        #jump-button:active {
            background-color: rgba(255, 200, 100, 1);
        }
        
        @media (max-width: 768px) {
            #ui {
                font-size: 12px;
                padding: 10px;
                max-width: 200px;
            }
        }
    </style>
</head>
<body>
    <div id="ui">
        <h2>ðŸ§± LEGO City Game</h2>
        <p>ðŸŽ® W, A, S, D to move <span id="vehicleMode"></span></p>
        <p id="statusText">ðŸ‘¤ You are the red LEGO character</p>
        <p id="vehiclePrompt"></p>
        <p>ðŸš« Collision detection enabled!</p>
        <p>ðŸš¶ NPCs walk around the city</p>
    </div>

    <!-- Mobile controls -->
    <div id="joystick-container">
        <div id="joystick-base">
            <div id="joystick-stick"></div>
        </div>
    </div>
    <div id="action-button">E</div>
    <div id="jump-button">â¬†</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 50, 200);

        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.camera.left = -100;
        dirLight.shadow.camera.right = 100;
        dirLight.shadow.camera.top = 100;
        dirLight.shadow.camera.bottom = -100;
        scene.add(dirLight);

        // Ground
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Function to create a LEGO-style character
        function createLegoCharacter(color) {
            const character = new THREE.Group();

            // Body
            const bodyGeometry = new THREE.BoxGeometry(0.8, 1.2, 0.5);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1.2;
            body.castShadow = true;
            character.add(body);

            // Head
            const headGeometry = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffdbac });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.1;
            head.castShadow = true;
            character.add(head);

            // Arms
            const armGeometry = new THREE.BoxGeometry(0.2, 0.8, 0.2);
            const armMaterial = new THREE.MeshStandardMaterial({ color: color });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.5, 1.2, 0);
            leftArm.castShadow = true;
            character.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.5, 1.2, 0);
            rightArm.castShadow = true;
            character.add(rightArm);

            // Legs
            const legGeometry = new THREE.BoxGeometry(0.3, 0.9, 0.3);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x0000aa });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.25, 0.45, 0);
            leftLeg.castShadow = true;
            character.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.25, 0.45, 0);
            rightLeg.castShadow = true;
            character.add(rightLeg);

            return { group: character, leftArm, rightArm, leftLeg, rightLeg };
        }

        // Create player
        const playerData = createLegoCharacter(0xff0000);
        const player = playerData.group;
        player.position.set(0, 0, 0);
        scene.add(player);

        // Game state
        let isInVehicle = false;
        let currentVehicle = null;

        // Buildings
        const buildings = [];
        const buildingPositions = [
            { x: -20, z: -20, w: 8, h: 15, d: 8, color: 0x8b4513 },
            { x: 20, z: -20, w: 10, h: 25, d: 10, color: 0x708090 },
            { x: -25, z: 25, w: 12, h: 20, d: 8, color: 0x4682b4 },
            { x: 30, z: 30, w: 8, h: 18, d: 12, color: 0x2f4f4f },
            { x: -40, z: -40, w: 10, h: 22, d: 10, color: 0x696969 },
            { x: 40, z: -35, w: 15, h: 30, d: 15, color: 0x556b2f },
        ];

        buildingPositions.forEach(pos => {
            const buildingGeometry = new THREE.BoxGeometry(pos.w, pos.h, pos.d);
            const buildingMaterial = new THREE.MeshStandardMaterial({ color: pos.color });
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.set(pos.x, pos.h / 2, pos.z);
            building.castShadow = true;
            building.receiveShadow = true;
            scene.add(building);
            buildings.push({
                mesh: building,
                bounds: {
                    minX: pos.x - pos.w / 2,
                    maxX: pos.x + pos.w / 2,
                    minZ: pos.z - pos.d / 2,
                    maxZ: pos.z + pos.d / 2
                }
            });
        });

        // Vehicles
        const vehicles = [];
        const vehicleData = [
            { x: -15, z: 5, color: 0x0000ff, name: 'Blue Car' },
            { x: 10, z: -10, color: 0xffff00, name: 'Yellow Car' },
            { x: -5, z: 15, color: 0x00ff00, name: 'Green Car' },
            { x: 25, z: 10, color: 0xff0000, name: 'Red Car' },
        ];

        vehicleData.forEach(data => {
            const carGroup = new THREE.Group();
            
            const bodyGeometry = new THREE.BoxGeometry(2, 1, 4);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: data.color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            carGroup.add(body);

            const roofGeometry = new THREE.BoxGeometry(1.5, 0.8, 2);
            const roof = new THREE.Mesh(roofGeometry, bodyMaterial);
            roof.position.set(0, 1.4, -0.3);
            roof.castShadow = true;
            carGroup.add(roof);

            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 16);
            const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            
            const wheels = [];
            const wheelPositions = [
                { x: -0.8, y: 0.3, z: 1.2 },
                { x: 0.8, y: 0.3, z: 1.2 },
                { x: -0.8, y: 0.3, z: -1.2 },
                { x: 0.8, y: 0.3, z: -1.2 },
            ];

            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.position.set(pos.x, pos.y, pos.z);
                wheel.rotation.z = Math.PI / 2;
                wheel.castShadow = true;
                carGroup.add(wheel);
                wheels.push(wheel);
            });

            carGroup.position.set(data.x, 0, data.z);
            scene.add(carGroup);
            vehicles.push({ 
                mesh: carGroup, 
                bounds: { w: 2, d: 4 },
                name: data.name,
                wheels: wheels,
                prevX: data.x,
                prevZ: data.z
            });
        });

        // NPCs
        const npcs = [];
        const npcData = [
            { x: 8, z: 8, vx: 0.03, vz: 0.02 },
            { x: -12, z: 10, vx: -0.02, vz: 0.03 },
            { x: 15, z: -15, vx: 0.025, vz: -0.025 },
            { x: -8, z: -12, vx: -0.03, vz: -0.02 },
        ];

        npcData.forEach(data => {
            const colors = [0x00ff00, 0xffff00, 0xff00ff, 0x00ffff];
            const npcData = createLegoCharacter(colors[Math.floor(Math.random() * colors.length)]);
            npcData.group.position.set(data.x, 0, data.z);
            scene.add(npcData.group);

            npcs.push({ 
                ...npcData,
                vx: data.vx, 
                vz: data.vz,
                bounds: { minX: -30, maxX: 30, minZ: -30, maxZ: 30 }
            });
        });

        // Camera
        camera.position.set(0, 15, 20);
        camera.lookAt(player.position);

        // Controls
        const keys = { w: false, a: false, s: false, d: false, space: false };
        
        // Joystick variables
        let joystickActive = false;
        let joystickX = 0;
        let joystickY = 0;
        
        // Jump variables
        let isJumping = false;
        let jumpVelocity = 0;
        const jumpStrength = 0.4;
        const gravity = 0.02;

        // Detect touch device and show mobile controls
        function isTouchDevice() {
            return (('ontouchstart' in window) ||
                   (navigator.maxTouchPoints > 0) ||
                   (navigator.msMaxTouchPoints > 0));
        }

        if (isTouchDevice()) {
            document.getElementById('joystick-container').style.display = 'block';
            document.getElementById('action-button').style.display = 'block';
            document.getElementById('jump-button').style.display = 'block';
        }

        // Joystick controls
        const joystickBase = document.getElementById('joystick-base');
        const joystickStick = document.getElementById('joystick-stick');
        const actionButton = document.getElementById('action-button');
        const jumpButton = document.getElementById('jump-button');

        let touchId = null;
        const maxDistance = 45; // Maximum distance stick can move from center

        joystickBase.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchId = e.touches[0].identifier;
            joystickActive = true;
            updateJoystick(e.touches[0]);
        });

        document.addEventListener('touchmove', (e) => {
            if (!joystickActive || touchId === null) return;
            
            for (let touch of e.touches) {
                if (touch.identifier === touchId) {
                    e.preventDefault();
                    updateJoystick(touch);
                    break;
                }
            }
        });

        document.addEventListener('touchend', (e) => {
            for (let touch of e.changedTouches) {
                if (touch.identifier === touchId) {
                    joystickActive = false;
                    touchId = null;
                    joystickX = 0;
                    joystickY = 0;
                    joystickStick.style.transform = 'translate(-50%, -50%)';
                    break;
                }
            }
        });

        function updateJoystick(touch) {
            const rect = joystickBase.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            let deltaX = touch.clientX - centerX;
            let deltaY = touch.clientY - centerY;
            
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            if (distance > maxDistance) {
                const angle = Math.atan2(deltaY, deltaX);
                deltaX = Math.cos(angle) * maxDistance;
                deltaY = Math.sin(angle) * maxDistance;
            }
            
            joystickStick.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
            
            // Normalize joystick values to -1 to 1
            joystickX = deltaX / maxDistance;
            joystickY = deltaY / maxDistance;
        }

        // Action button for mobile
        actionButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleEPress();
        });
        
        // Jump button for mobile
        jumpButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleJump();
        });

        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (key in keys) keys[key] = true;
            if (key === 'e') handleEPress();
            if (key === ' ' || key === 'space') {
                e.preventDefault();
                handleJump();
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (key in keys) keys[key] = false;
        });

        // UI elements
        const statusText = document.getElementById('statusText');
        const vehiclePrompt = document.getElementById('vehiclePrompt');
        const vehicleMode = document.getElementById('vehicleMode');

        // Handle E key press
        function handleEPress() {
            if (isInVehicle) {
                // Exit vehicle
                isInVehicle = false;
                player.visible = true;
                player.position.x = currentVehicle.mesh.position.x + 3;
                player.position.z = currentVehicle.mesh.position.z;
                player.position.y = 0;
                currentVehicle = null;
                statusText.textContent = 'ðŸ‘¤ You are the red LEGO character';
                vehicleMode.textContent = '';
            } else {
                // Try to enter vehicle
                const nearestVehicle = findNearestVehicle();
                if (nearestVehicle) {
                    isInVehicle = true;
                    currentVehicle = nearestVehicle;
                    player.visible = false;
                    isJumping = false;
                    jumpVelocity = 0;
                    statusText.textContent = 'ðŸš— Driving! Press E to exit';
                    vehicleMode.textContent = '/ steer';
                }
            }
        }
        
        // Handle jump
        function handleJump() {
            if (!isInVehicle && !isJumping && player.position.y <= 0.01) {
                isJumping = true;
                jumpVelocity = jumpStrength;
            }
        }

        // Find nearest vehicle
        function findNearestVehicle() {
            const range = 4;
            for (let vehicle of vehicles) {
                const dx = player.position.x - vehicle.mesh.position.x;
                const dz = player.position.z - vehicle.mesh.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                if (distance < range) {
                    return vehicle;
                }
            }
            return null;
        }

        // Collision detection
        function checkCollision(x, z, radius = 0.8, ignoreVehicles = false, checkingVehicle = null) {
            // Check buildings
            for (let building of buildings) {
                const b = building.bounds;
                if (x + radius > b.minX && x - radius < b.maxX &&
                    z + radius > b.minZ && z - radius < b.maxZ) {
                    return true;
                }
            }
            
            // Check vehicles
            if (!ignoreVehicles) {
                for (let vehicle of vehicles) {
                    if (checkingVehicle && vehicle === checkingVehicle) continue;
                    
                    const cx = vehicle.mesh.position.x;
                    const cz = vehicle.mesh.position.z;
                    const hw = vehicle.bounds.w / 2 + radius;
                    const hd = vehicle.bounds.d / 2 + radius;
                    if (Math.abs(x - cx) < hw && Math.abs(z - cz) < hd) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        // Check NPC collisions with vehicle
        function checkNPCVehicleCollision() {
            if (!isInVehicle || !currentVehicle) return;

            const carSpeed = Math.sqrt(
                Math.pow(currentVehicle.mesh.position.x - currentVehicle.prevX, 2) +
                Math.pow(currentVehicle.mesh.position.z - currentVehicle.prevZ, 2)
            );

            npcs.forEach(npc => {
                const dx = npc.group.position.x - currentVehicle.mesh.position.x;
                const dz = npc.group.position.z - currentVehicle.mesh.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);

                if (distance < 3 && carSpeed > 0.1) {
                    const angle = Math.atan2(dz, dx);
                    const throwForce = 15;
                    npc.throwVelocity = {
                        x: Math.cos(angle) * throwForce,
                        z: Math.sin(angle) * throwForce,
                        y: 8,
                        gravity: 0.5
                    };
                }
            });

            currentVehicle.prevX = currentVehicle.mesh.position.x;
            currentVehicle.prevZ = currentVehicle.mesh.position.z;
        }

        // Animation
        let walkCycle = 0;
        let wheelRotation = 0;

        function animate() {
            requestAnimationFrame(animate);

            const speed = isInVehicle ? 0.3 : 0.15;
            let moved = false;

            if (isInVehicle && currentVehicle) {
                // Vehicle controls
                let newX = currentVehicle.mesh.position.x;
                let newZ = currentVehicle.mesh.position.z;
                let rotation = currentVehicle.mesh.rotation.y;

                if (keys.w) {
                    newX -= Math.sin(rotation) * speed;
                    newZ -= Math.cos(rotation) * speed;
                    moved = true;
                    wheelRotation += 0.2;
                }
                if (keys.s) {
                    newX += Math.sin(rotation) * speed;
                    newZ += Math.cos(rotation) * speed;
                    moved = true;
                    wheelRotation -= 0.2;
                }
                if (keys.a) rotation += 0.05;
                if (keys.d) rotation -= 0.05;

                const vehicleRadius = 2.5;
                if (!checkCollision(newX, newZ, vehicleRadius, false, currentVehicle)) {
                    currentVehicle.mesh.position.x = newX;
                    currentVehicle.mesh.position.z = newZ;
                } else {
                    moved = false;
                }

                currentVehicle.mesh.rotation.y = rotation;

                currentVehicle.wheels.forEach(wheel => {
                    wheel.rotation.x = wheelRotation;
                });

                currentVehicle.mesh.position.x = Math.max(-90, Math.min(90, currentVehicle.mesh.position.x));
                currentVehicle.mesh.position.z = Math.max(-90, Math.min(90, currentVehicle.mesh.position.z));

            } else {
                // Player walking
                let newX = player.position.x;
                let newZ = player.position.z;
                let targetRotation = player.rotation.y;
                let moveX = 0;
                let moveZ = 0;

                // Keyboard controls
                if (keys.w) moveZ -= 1;
                if (keys.s) moveZ += 1;
                if (keys.a) moveX -= 1;
                if (keys.d) moveX += 1;

                // Joystick controls (override keyboard if active)
                if (joystickActive) {
                    moveX = joystickX;
                    moveZ = joystickY;
                }

                // If moving, calculate angle and apply movement
                if (moveX !== 0 || moveZ !== 0) {
                    moved = true;
                    
                    // Normalize diagonal movement to prevent faster diagonal speed
                    const magnitude = Math.sqrt(moveX * moveX + moveZ * moveZ);
                    const normalizedX = (moveX / magnitude) * speed;
                    const normalizedZ = (moveZ / magnitude) * speed;
                    
                    newX += normalizedX;
                    newZ += normalizedZ;
                    
                    // Calculate rotation based on movement direction
                    targetRotation = Math.atan2(-normalizedX, -normalizedZ);
                }

                // Smooth rotation towards target
                if (moved) {
                    let rotDiff = targetRotation - player.rotation.y;
                    // Normalize to -PI to PI range
                    while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                    while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                    player.rotation.y += rotDiff * 0.15; // Smooth rotation
                }

                if (!checkCollision(newX, newZ)) {
                    player.position.x = newX;
                    player.position.z = newZ;
                } else {
                    if (!checkCollision(newX, player.position.z)) {
                        player.position.x = newX;
                    } else if (!checkCollision(player.position.x, newZ)) {
                        player.position.z = newZ;
                    }
                }

                player.position.x = Math.max(-90, Math.min(90, player.position.x));
                player.position.z = Math.max(-90, Math.min(90, player.position.z));

                // Handle jumping
                if (isJumping) {
                    player.position.y += jumpVelocity;
                    jumpVelocity -= gravity;
                    
                    // Land on ground
                    if (player.position.y <= 0) {
                        player.position.y = 0;
                        isJumping = false;
                        jumpVelocity = 0;
                    }
                }

                if (moved) {
                    walkCycle += 0.15;
                    playerData.leftLeg.rotation.x = Math.sin(walkCycle) * 0.5;
                    playerData.rightLeg.rotation.x = Math.sin(walkCycle + Math.PI) * 0.5;
                    playerData.leftArm.rotation.x = Math.sin(walkCycle + Math.PI) * 0.3;
                    playerData.rightArm.rotation.x = Math.sin(walkCycle) * 0.3;
                } else {
                    playerData.leftLeg.rotation.x *= 0.9;
                    playerData.rightLeg.rotation.x *= 0.9;
                    playerData.leftArm.rotation.x *= 0.9;
                    playerData.rightArm.rotation.x *= 0.9;
                }

                const nearVehicle = findNearestVehicle();
                if (nearVehicle) {
                    vehiclePrompt.innerHTML = `<span class="highlight">ðŸš— Press E to enter ${nearVehicle.name}</span>`;
                } else {
                    vehiclePrompt.textContent = '';
                }
            }

            // Update NPCs
            npcs.forEach(npc => {
                if (npc.throwVelocity) {
                    npc.group.position.x += npc.throwVelocity.x * 0.1;
                    npc.group.position.z += npc.throwVelocity.z * 0.1;
                    npc.group.position.y += npc.throwVelocity.y * 0.1;
                    
                    npc.throwVelocity.y -= npc.throwVelocity.gravity;
                    
                    npc.group.rotation.x += 0.2;
                    npc.group.rotation.z += 0.15;

                    if (npc.group.position.y <= 0) {
                        npc.group.position.y = 0;
                        npc.group.rotation.x = 0;
                        npc.group.rotation.z = 0;
                        npc.throwVelocity = null;
                    }
                    
                    return;
                }

                let newNpcX = npc.group.position.x + npc.vx;
                let newNpcZ = npc.group.position.z + npc.vz;

                if (checkCollision(newNpcX, newNpcZ, 0.5)) {
                    npc.vx *= -1;
                    npc.vz *= -1;
                } else {
                    npc.group.position.x = newNpcX;
                    npc.group.position.z = newNpcZ;
                }

                if (npc.group.position.x < npc.bounds.minX || npc.group.position.x > npc.bounds.maxX) {
                    npc.vx *= -1;
                }
                if (npc.group.position.z < npc.bounds.minZ || npc.group.position.z > npc.bounds.maxZ) {
                    npc.vz *= -1;
                }

                npc.leftLeg.rotation.x = Math.sin(walkCycle) * 0.3;
                npc.rightLeg.rotation.x = Math.sin(walkCycle + Math.PI) * 0.3;
                npc.leftArm.rotation.x = Math.sin(walkCycle + Math.PI) * 0.2;
                npc.rightArm.rotation.x = Math.sin(walkCycle) * 0.2;
            });

            checkNPCVehicleCollision();

            // Camera follows
            if (isInVehicle && currentVehicle) {
                const camDistance = 25;
                const camHeight = 12;
                const angle = currentVehicle.mesh.rotation.y;
                camera.position.x = currentVehicle.mesh.position.x + Math.sin(angle) * camDistance;
                camera.position.z = currentVehicle.mesh.position.z + Math.cos(angle) * camDistance;
                camera.position.y = camHeight;
                camera.lookAt(currentVehicle.mesh.position);
            } else {
                camera.position.x = player.position.x;
                camera.position.z = player.position.z + 20;
                camera.position.y = 15;
                camera.lookAt(player.position);
            }

            renderer.render(scene, camera);
        }

        animate();

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>